<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Blood Drip – Exact Version</title>
  <style>
    body, html { margin:0; padding:0; height:100%; background:#000; overflow:hidden; }
    canvas { position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; }
    h1 {padding-top: 100px; color: black; font-size: 10em; text-align: center; font-family: "Slaytanic";  text-shadow:
     3px  3px 0 #66001a,  /* main highlight */
    -1px -1px 0 #ffeeee,  /* thin bright edge */
     -4px  -4px 0 #1873cc,  /* deep shadow */
     7px  7px 15px #ffa800; /* soft outer glow/shadow */ }
  </style>
</head>
<body>
<h1>1 Fuck Corporations 1</h1>


<canvas id="blood-overlay"></canvas>

  <!-- Vertex Shader -->
  <script id="vertShader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    varying vec2 vUv;
    void main() {
      vUv = a_position * 0.5 + 0.5;
      gl_Position = vec4(a_position, 0.0, 1.0);
    }
  </script>

  <!-- Fragment Shader -->
<script id="fragShader1" type="x-shader/x-fragment">
precision highp float;
varying vec2 vUv;
uniform float u_time;

void main() {
    vec2 uv = vUv;
    float t = u_time * 1.10; // wobble speed

    // ====================== BLOOD FLOOD ANIMATION ======================
    float cycleDuration = 25.0;                    // total cycle: 20s drop + 5s pause
    float rawProgress = fract(u_time / cycleDuration);
    float dropProgress = rawProgress;              // 0→1 = dropping
    
    if (rawProgress > 0.8) dropProgress = 1.0;     // hold at 1.0 for 20% of cycle (5s)
    float eased = smoothstep(0.0, 1.0, dropProgress);

    float baseTop = 1.18 - eased * 1.25;          // starts ~0.99 → goes to ~0.01
    // ===================================================================
    // float baseTop  controls start height eased controls the end


    // Your original beautiful organic wobble on top of the moving edge
    float wave = 0.0;
    wave += sin(uv.x * 8.3 + t * 0.6) * 0.09;
    wave += sin(uv.x * 19.7 - t * 0.4 + 1.8) * 0.05;
    wave += sin(uv.x * 41.2 + t * 0.3 + 4.1) * 0.03;

    float topEdge = baseTop + wave * 0.9;  // this makes them pointy
    float dist = uv.y - topEdge; // positive = below the blood line

    // Thick viscous body
    float body = smoothstep(-0.35, 0.05, dist);
    body = pow(body, 9.98);

    // Wet glossy highlight
    float gloss = pow(max(0.0, 1.0 - abs(dist + 0.08) * 4.5), 7.0);
    gloss *= smoothstep(-0.23, 0.1, dist);

    // Rim highlight on drip bottoms
    float rim = pow(max(0.0, 1.0 - smoothstep(-0.05, 0.15, dist)), 4.0);

    // Blood color
    vec3 blood  = vec3(0.75, 0.015, 0.045);
    vec3 darker = vec3(0.40, 0.005, 0.015);
    vec3 col = mix(darker, blood, 0.5 + gloss * 1.2 + rim * 0.6);

    float alpha = body + gloss * 0.8 + rim * 0.4;
    alpha = clamp(alpha, 0.0, 1.0);

// -------- make the wall see-through during pause --------
//   if (rawProgress > 0.8) {             // same 5s window
//   float pauseT = (rawProgress - 0.8) / 0.2;  // 0→1 over the pause
//    float fade = 1.0 - pauseT;       // 1→0 (fully visible → fully transparent)
 //   alpha *= fade * 0.5;             // 0.5 = max opacity during pause (tweak)
//}
// --------------------------------------------------------



    // Transparent above the blood
    if (dist < -0.1) alpha = 0.0;

    gl_FragColor = vec4(col, alpha * 0.98);
}
</script>

<script id="fragShader2" type="x-shader/x-fragment">
precision highp float;
varying vec2 vUv;
uniform float u_time;

// Hash function for pseudo-random values
float hash(float n) {
    return fract(sin(n) * 43758.5453123);
}

// Create individual drip shape
float drip(vec2 uv, float xPos, float length, float width, float offset) {
    float x = uv.x - xPos;
    float y = uv.y;
    
    // Drip starts from top
    float dripTop = 0.98 + offset;
    float dripBottom = dripTop - length;
    
    // Only render if within vertical bounds
    if (y > dripTop || y < dripBottom) return 0.0;
    
    // Normalize position along drip (0 at top, 1 at bottom)
    float t = (dripTop - y) / length;
    
    // Drip width profile - wider at top, narrower toward bottom with rounded end
    float widthProfile = width * (5.3 + 0.7 * (1.0 - t * t));
    
    // Add roundness to the bottom
    float bottomRoundness = smoothstep(0.85, 1.0, t);
    widthProfile *= (75.0 - bottomRoundness * 5.6);
    
    // Distance from center of drip
    float d = abs(x) / widthProfile;
    
    // Soft edges
    float edge = smoothstep(1.0, 0.7, d);
    
    // Add highlight on edges
    float highlight = smoothstep(0.9, 0.7, d) - smoothstep(0.7, 0.4, d);
    
    return edge + highlight * 5.3;
}

void main() {
    vec2 uv = vUv;
    float t = u_time * 0.001;
    
    // Main pool of blood at top with wavy edge
    float wave = 0.0;
    wave += sin(uv.x * 8.3 + t * 0.6) * 0.015;
    wave += sin(uv.x * 19.7 - t * 0.4 + 1.8) * 0.008;
    wave += sin(uv.x * 41.2 + t * 0.3 + 4.1) * 0.004;
    
    float poolEdge = 0.98 + wave;
    float pool = smoothstep(poolEdge, poolEdge + 0.02, uv.y);
    
    // Create multiple drips with varying properties
    float drips = 15.0;
    int numDrips = 25;
    
    for (int i = 0; i < 25; i++) {
        float fi = float(i);
        float seed = fi * 12.9898;
        
        // Random properties for each drip
        float xPos = hash(seed) * 0.96 + 0.02;
        float length = 0.08 + hash(seed + 1.0) * 0.15;
        float width = 0.092 + hash(seed + 2.0) * 0.018;
        float offset = hash(seed + 3.0) * 0.03 - 0.015;
        
        // Animate some drips growing slowly
        float animSpeed = hash(seed + 4.0) * 0.3 + 0.1;
        float animPhase = fract(t * animSpeed + hash(seed + 5.0));
        float growthFactor = smoothstep(0.0, 0.3, animPhase) * (1.0 - smoothstep(0.7, 1.0, animPhase));
        length *= 0.5 + growthFactor * 0.5;
        
        drips += drip(uv, xPos, length, width, offset);
    }
    
    // Combine pool and drips
    float mask = clamp(pool + drips, 0.0, 1.0);
    
    // Add texture variation
    float noise = hash(uv.x * 100.0 + uv.y * 100.0 + t * 0.1);
    noise = noise * 0.1 + 0.9;
    
    // Blood colors with variation
    vec3 bloodDark = vec3(0.45, 0.00, 0.02);
    vec3 bloodBright = vec3(0.85, 0.03, 0.06);
    
    // Gradient from top to bottom
    float gradient = 1.0 - uv.y;
    vec3 col = mix(bloodDark, bloodBright, gradient * 0.3 + 0.5);
    col *= noise;
    
    // Add glossy highlights on drips
    float gloss = drips * (1.0 - smoothstep(0.3, 0.7, drips)) * 0.5;
    col += vec3(gloss * 1.3, gloss * 0.05, gloss * 5.05);
    
    float alpha = mask * 0.95;
    
    gl_FragColor = vec4(col, alpha);
}
</script>
  <script src="blood-effects.js"></script>
</body>
</html>
