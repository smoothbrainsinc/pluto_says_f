<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Essential for mobile: proper scaling, no user zoom issues -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Blood Drip – Exact Version</title>
  <style>
    body, html { 
      margin:0; padding:0; height:100%; background:#000; overflow:hidden; 
    }
    canvas { 
      position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; 
    }
    h1 { 
      padding-top: 100px; color: white; font-size: 10em; text-align: center; 
      font-family: "Slaytanic"; text-shadow:
       3px  3px 0 #66001a,
      -1px -1px 0 #ffeeee,
       -4px  -4px 0 #092b4d,
       7px  7px 15px #1873cc; 
      position: relative; z-index: 1; /* Ensures text stays above blood */
    }
  </style>
</head>
<body>
<h1>1 God Hates Us All 1</h1>

<canvas id="blood-overlay"></canvas>

  <!-- Vertex Shader -->
  <script id="vertShader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    varying vec2 vUv;
    void main() {
      vUv = a_position * 0.5 + 0.5;
      gl_Position = vec4(a_position, 0.0, 1.0);
    }
  </script>

  <!-- Primary Fragment Shader: Flooding blood (recommended) -->
  <script id="fragShader" type="x-shader/x-fragment">
    precision highp float; /* Better consistency/performance on mobile */
    varying vec2 vUv;
    uniform float u_time;

    void main() {
        vec2 uv = vUv;
        float t = u_time * 1.10;

        float cycleDuration = 25.0;
        float rawProgress = fract(u_time / cycleDuration);
        float dropProgress = rawProgress;
        
        if (rawProgress > 0.8) dropProgress = 1.0;
        float eased = smoothstep(0.0, 1.0, dropProgress);

        float baseTop = 1.18 - eased * 1.25;

        float wave = 0.0;
        wave += sin(uv.x * 8.3 + t * 0.6) * 0.09;
        wave += sin(uv.x * 19.7 - t * 0.4 + 1.8) * 0.05;
        wave += sin(uv.x * 41.2 + t * 0.3 + 4.1) * 0.03;

        float topEdge = baseTop + wave * 0.9;
        float dist = uv.y - topEdge;

        float body = smoothstep(-0.35, 0.05, dist);
        body = pow(body, 9.98);

        float gloss = pow(max(0.0, 1.0 - abs(dist + 0.08) * 4.5), 7.0);
        gloss *= smoothstep(-0.23, 0.1, dist);

        float rim = pow(max(0.0, 1.0 - smoothstep(-0.05, 0.15, dist)), 4.0);

        vec3 blood  = vec3(0.75, 0.015, 0.045);
        vec3 darker = vec3(0.40, 0.005, 0.015);
        vec3 col = mix(darker, blood, 0.5 + gloss * 1.2 + rim * 0.6);

        float alpha = body + gloss * 0.8 + rim * 0.4;
        alpha = clamp(alpha, 0.0, 1.0);

        if (dist < -0.1) alpha = 0.0;

        gl_FragColor = vec4(col, alpha * 0.98);
    }
  </script>

  <!-- Alternative Fragment Shader: Individual drips (commented out – loads over primary) -->
  <!--
  <script id="fragShader" type="x-shader/x-fragment">
    ... (your second shader code here) ...
  </script>
  -->

  <script>
    (() => {
      const canvas = document.getElementById("blood-overlay");
      const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
      if (!gl) {
        alert("WebGL not supported");
        return;
      }

      const vsSource = document.getElementById("vertShader").textContent;
      const fsSource = document.getElementById("fragShader").textContent;

      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader, vsSource);
      gl.compileShader(vertexShader);

      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, fsSource);
      gl.compileShader(fragmentShader);

      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      gl.useProgram(program);

      // Full-screen quad
      const vertices = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
      const buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

      const posLoc = gl.getAttribLocation(program, "a_position");
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

      const timeLoc = gl.getUniformLocation(program, "u_time");

      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

      function resize() {
        // Use clientWidth/Height for CSS pixel size, multiply by DPR for sharp rendering on retina/mobile
        const dpr = window.devicePixelRatio || 1;
        canvas.width = canvas.clientWidth * dpr;
        canvas.height = canvas.clientHeight * dpr;
        gl.viewport(0, 0, canvas.width, canvas.height);
      }

      resize();
      window.addEventListener("resize", resize);
      // Extra listeners for mobile orientation/address bar changes
      window.addEventListener("orientationchange", () => setTimeout(resize, 100));

      function render(time) {
        gl.uniform1f(timeLoc, time * 0.001);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        requestAnimationFrame(render);
      }
      requestAnimationFrame(render);
    })();
  </script>
</body>
</html>
