<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Blood Drip – Exact Version</title>
  <style>
    body, html { margin:0; padding:0; height:100%; background:#000; overflow:hidden; }
    canvas { position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; }
    h1 { 
      padding-top: 100px; color: white; font-size: 10em; text-align: center; 
      font-family: "Slaytanic"; text-shadow:
       3px  3px 0 #66001a,
      -1px -1px 0 #ffeeee,
       -4px  -4px 0 #092b4d,
       7px  7px 15px #1873cc; 
      position: relative; z-index: 1;
    }
  </style>
</head>
<body>
<h1>1 God Hates Us All 1</h1>

<canvas id="blood-overlay"></canvas>

  <!-- Vertex Shader -->
  <script id="vertShader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    varying vec2 vUv;
    void main() {
      vUv = a_position * 0.5 + 0.5;
      gl_Position = vec4(a_position, 0.0, 1.0);
    }
  </script>

  <!-- PRIMARY: Flooding blood wave (active by default) -->
  <script id="fragShader" type="x-shader/x-fragment">
    precision highp float;
    varying vec2 vUv;
    uniform float u_time;

    void main() {
        vec2 uv = vUv;
        float t = u_time * 1.10;

        float cycleDuration = 25.0;
        float rawProgress = fract(u_time / cycleDuration);
        float dropProgress = rawProgress;
        
        if (rawProgress > 0.8) dropProgress = 1.0;
        float eased = smoothstep(0.0, 1.0, dropProgress);

        float baseTop = 1.18 - eased * 1.25;

        float wave = 0.0;
        wave += sin(uv.x * 8.3 + t * 0.6) * 0.09;
        wave += sin(uv.x * 19.7 - t * 0.4 + 1.8) * 0.05;
        wave += sin(uv.x * 41.2 + t * 0.3 + 4.1) * 0.03;

        float topEdge = baseTop + wave * 0.9;
        float dist = uv.y - topEdge;

        float body = smoothstep(-0.35, 0.05, dist);
        body = pow(body, 9.98);

        float gloss = pow(max(0.0, 1.0 - abs(dist + 0.08) * 4.5), 7.0);
        gloss *= smoothstep(-0.23, 0.1, dist);

        float rim = pow(max(0.0, 1.0 - smoothstep(-0.05, 0.15, dist)), 4.0);

        vec3 blood  = vec3(0.75, 0.015, 0.045);
        vec3 darker = vec3(0.40, 0.005, 0.015);
        vec3 col = mix(darker, blood, 0.5 + gloss * 1.2 + rim * 0.6);

        float alpha = body + gloss * 0.8 + rim * 0.4;
        alpha = clamp(alpha, 0.0, 1.0);

        if (dist < -0.1) alpha = 0.0;

        gl_FragColor = vec4(col, alpha * 0.98);
    }
  </script>

  <!-- ALTERNATIVE: Individual hanging/growing drips (commented — move comment tags to use this one instead) -->
  
  <script id="fragShader" type="x-shader/x-fragment">
    precision highp float;
    varying vec2 vUv;
    uniform float u_time;

    float hash(float n) {
        return fract(sin(n) * 43758.5453123);
    }

    float drip(vec2 uv, float xPos, float length, float width, float offset) {
        float x = uv.x - xPos;
        float y = uv.y;
        
        float dripTop = 0.98 + offset;
        float dripBottom = dripTop - length;
        
        if (y > dripTop || y < dripBottom) return 0.0;
        
        float t = (dripTop - y) / length;
        
        float widthProfile = width * (5.3 + 0.7 * (1.0 - t * t));
        
        float bottomRoundness = smoothstep(0.85, 1.0, t);
        widthProfile *= (75.0 - bottomRoundness * 5.6);
        
        float d = abs(x) / widthProfile;
        
        float edge = smoothstep(1.0, 0.7, d);
        
        float highlight = smoothstep(0.9, 0.7, d) - smoothstep(0.7, 0.4, d);
        
        return edge + highlight * 5.3;
    }

    void main() {
        vec2 uv = vUv;
        float t = u_time * 0.001;
        
        float wave = 0.0;
        wave += sin(uv.x * 8.3 + t * 0.6) * 0.015;
        wave += sin(uv.x * 19.7 - t * 0.4 + 1.8) * 0.008;
        wave += sin(uv.x * 41.2 + t * 0.3 + 4.1) * 0.004;
        
        float poolEdge = 0.98 + wave;
        float pool = smoothstep(poolEdge, poolEdge + 0.02, uv.y);
        
        float drips = 15.0;
        
        for (int i = 0; i < 25; i++) {
            float fi = float(i);
            float seed = fi * 12.9898;
            
            float xPos = hash(seed) * 0.96 + 0.02;
            float length = 0.08 + hash(seed + 1.0) * 0.15;
            float width = 0.092 + hash(seed + 2.0) * 0.018;
            float offset = hash(seed + 3.0) * 0.03 - 0.015;
            
            float animSpeed = hash(seed + 4.0) * 0.3 + 0.1;
            float animPhase = fract(t * animSpeed + hash(seed + 5.0));
            float growthFactor = smoothstep(0.0, 0.3, animPhase) * (1.0 - smoothstep(0.7, 1.0, animPhase));
            length *= 0.5 + growthFactor * 0.5;
            
            drips += drip(uv, xPos, length, width, offset);
        }
        
        float mask = clamp(pool + drips, 0.0, 1.0);
        
        float noise = hash(uv.x * 100.0 + uv.y * 100.0 + t * 0.1);
        noise = noise * 0.1 + 0.9;
        
        vec3 bloodDark = vec3(0.45, 0.00, 0.02);
        vec3 bloodBright = vec3(0.85, 0.03, 0.06);
        
        float gradient = 1.0 - uv.y;
        vec3 col = mix(bloodDark, bloodBright, gradient * 0.3 + 0.5);
        col *= noise;
        
        float gloss = drips * (1.0 - smoothstep(0.3, 0.7, drips)) * 0.5;
        col += vec3(gloss * 1.3, gloss * 0.05, gloss * 5.05);
        
        float alpha = mask * 0.95;
        
        gl_FragColor = vec4(col, alpha);
    }
  </script>
  

  <script>
    (() => {
      const canvas = document.getElementById("blood-overlay");
      const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
      if (!gl) {
        alert("WebGL not supported on this device/browser");
        return;
      }

      const vsSource = document.getElementById("vertShader").textContent;
      const fsSource = document.getElementById("fragShader").textContent;

      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader, vsSource);
      gl.compileShader(vertexShader);

      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, fsSource);
      gl.compileShader(fragmentShader);

      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      gl.useProgram(program);

      const vertices = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
      const buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

      const posLoc = gl.getAttribLocation(program, "a_position");
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

      const timeLoc = gl.getUniformLocation(program, "u_time");

      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

      function resize() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = canvas.clientWidth * dpr;
        canvas.height = canvas.clientHeight * dpr;
        gl.viewport(0, 0, canvas.width, canvas.height);
      }

      resize();
      window.addEventListener("resize", resize);
      window.addEventListener("orientationchange", () => setTimeout(resize, 100));

      function render(time) {
        gl.uniform1f(timeLoc, time * 0.001);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        requestAnimationFrame(render);
      }
      requestAnimationFrame(render);
    })();
  </script>
</body>
</html>
